!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n(require("react"),require("react-dom"),require("tiny-warning")):"function"==typeof define&&define.amd?define(["react","react-dom","tiny-warning"],n):(e||self).reactCollapsed=n(e.react,e.reactDom,e.tinyWarning)}(this,function(e,n,t){function o(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function r(e){if(e&&e.__esModule)return e;var n=Object.create(null);return e&&Object.keys(e).forEach(function(t){if("default"!==t){var o=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(n,t,o.get?o:{enumerable:!0,get:function(){return e[t]}})}}),n.default=e,n}var i=r(e),l=o(t);function a(){return a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},a.apply(this,arguments)}function u(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n.indexOf(t=i[o])>=0||(r[t]=e[t]);return r}var c=function(){};function d(e){return null!=e&&e.current?e.current.scrollHeight:(l.default(!0,"useCollapse was not able to find a ref to the collapse element via `getCollapseProps`. Ensure that the element exposes its `ref` prop. If it exposes the ref prop under a different name (like `innerRef`), use the `refKey` property to change it. Example:\n\n{...getCollapseProps({refKey: 'innerRef'})}"),"auto")}var f=function(){var e=arguments;return function(){var n=arguments;return[].slice.call(e).forEach(function(e){return e&&e.apply(void 0,[].slice.call(n))})}};function s(e,n){if(null!=e)if("function"==typeof e)e(n);else try{e.current=n}catch(t){throw new Error('Cannot assign value "'+n+'" to ref "'+e+'"')}}var p="undefined"!=typeof window?e.useLayoutEffect:e.useEffect,h=!1,v=0,g=function(){return++v},y=i.useId,m=["duration","easing","collapseStyles","expandStyles","onExpandStart","onExpandEnd","onCollapseStart","onCollapseEnd","isExpanded","defaultExpanded","hasDisabledAnimation"],E=["disabled","onClick"],b=["style","onTransitionEnd","refKey"];return function(t){var o,r,i=void 0===t?{}:t,v=i.duration,x=i.easing,C=void 0===x?"cubic-bezier(0.4, 0, 0.2, 1)":x,w=i.collapseStyles,S=void 0===w?{}:w,k=i.expandStyles,O=void 0===k?{}:k,j=i.onExpandStart,q=void 0===j?c:j,P=i.onExpandEnd,T=void 0===P?c:P,D=i.onCollapseStart,A=void 0===D?c:D,R=i.onCollapseEnd,F=void 0===R?c:R,K=i.isExpanded,I=i.defaultExpanded,M=void 0!==I&&I,N=i.hasDisabledAnimation,_=void 0!==N&&N,z=u(i,m),H=function(n,t){var o=e.useState(t||!1),r=o[0],i=o[1],a=e.useRef(null!=n),u=a.current?n:r,c=e.useCallback(function(e){a.current||i(e)},[]);return e.useEffect(function(){l.default(!(a.current&&null==n),"useCollapse is changing from controlled to uncontrolled. useCollapse should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop."),l.default(!(!a.current&&null!=n),"useCollapse is changing from uncontrolled to controlled. useCollapse should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop.")},[n]),[u,c]}(K,M),B=H[0],L=H[1],V=void 0!==y?y():function(n){var t=h?g():null,o=e.useState(t),r=o[0],i=o[1];return p(function(){null===r&&i(g())},[]),e.useEffect(function(){!1===h&&(h=!0)},[]),null!=r?String(r):void 0}(),W=e.useRef(null);o=W,r=function(e){},"production"!==process.env.NODE_ENV&&(r=function(e){if(null!=e&&e.current){var n=window.getComputedStyle(e.current),t=n.paddingTop,o=n.paddingBottom;l.default(!(t&&"0px"!==t||o&&"0px"!==o),"react-collapsed: Padding applied to the collapse element will cause the animation to break and not perform as expected. To fix, apply equivalent padding to the direct descendent of the collapse element.")}}),e.useEffect(function(){r(o)},[o]);var G,J,Q,U=(z.collapsedHeight||0)+"px",X={display:"0px"===U?"none":"block",height:U,overflow:"hidden"},Y=e.useState(B?{}:X),Z=Y[0],$=Y[1],ee=function(e){n.flushSync(function(){$(e)})},ne=function(e){ee(function(n){return a({},n,e)})};function te(e){if(_)return{};var n=v||function(e){if(!e||"string"==typeof e)return 0;var n=e/36;return Math.round(10*(4+15*Math.pow(n,.25)+n/5))}(e);return{transition:"height "+n+"ms "+C}}G=function(){B?requestAnimationFrame(function(){q(),ne(a({},O,{willChange:"height",display:"block",overflow:"hidden"})),requestAnimationFrame(function(){var e=d(W);ne(a({},te(e),{height:e}))})}):requestAnimationFrame(function(){A();var e=d(W);ne(a({},S,te(e),{willChange:"height",height:e})),requestAnimationFrame(function(){ne({height:U,overflow:"hidden"})})})},J=[B,U],Q=e.useRef(!0),e.useEffect(function(){if(!Q.current)return G();Q.current=!1},J);var oe=function(e){if(e.target===W.current&&"height"===e.propertyName)if(B){var n=d(W);n===Z.height?ee({}):ne({height:n}),T()}else Z.height===U&&(ee(X),F())};return{getToggleProps:function(e){var n=void 0===e?{}:e,t=n.disabled,o=void 0!==t&&t,r=n.onClick,i=void 0===r?c:r,l=u(n,E);return a({type:"button",role:"button",id:"react-collapsed-toggle-"+V,"aria-controls":"react-collapsed-panel-"+V,"aria-expanded":B,tabIndex:0,disabled:o},l,{onClick:o?c:f(i,function(){return L(function(e){return!e})})})},getCollapseProps:function(e){var n,t=void 0===e?{}:e,o=t.style,r=void 0===o?{}:o,i=t.onTransitionEnd,l=void 0===i?c:i,d=t.refKey,p=void 0===d?"ref":d,h=u(t,b);return a({id:"react-collapsed-panel-"+V,"aria-hidden":!B},h,((n={})[p]=function(){var e=[].slice.call(arguments);return e.every(function(e){return null==e})?null:function(n){e.forEach(function(e){s(e,n)})}}(W,h[p]),n.onTransitionEnd=f(oe,l),n.style=a({boxSizing:"border-box"},r,Z),n))},isExpanded:B,setExpanded:L}}});
//# sourceMappingURL=react-collapsed.umd.js.map
